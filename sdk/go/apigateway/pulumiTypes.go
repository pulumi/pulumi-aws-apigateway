// Code generated by Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package apigateway

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-apigateway/sdk/v2/go/apigateway/utilities"
	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lambda"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// LambdaAuthorizer provides the definition for a custom Authorizer for API Gateway.
type Authorizer struct {
	// Specifies the authorization mechanism for the client. Typical values are "oauth2" or "custom".
	AuthType *string `pulumi:"authType"`
	// The name for the Authorizer to be referenced as. This must be unique for each unique
	// authorizer within the API. If no name if specified, a name will be generated for you.
	AuthorizerName *string `pulumi:"authorizerName"`
	// The number of seconds during which the resulting IAM policy is cached. Default is 300s. You
	// can set this value to 0 to disable caching. Max value is 3600s. Note - if you are sharing an
	// authorizer across more than one route you will want to disable the cache or else it will
	// cause problems for you.
	AuthorizerResultTtlInSeconds *float64 `pulumi:"authorizerResultTtlInSeconds"`
	// The authorizerHandler specifies information about the authorizing Lambda.
	Handler *lambda.Function `pulumi:"handler"`
	// List of mapping expressions of the request parameters as the identity source. This indicates
	// where in the request identity information is expected. Applicable for the authorizer of the
	// "request" type only. Example: ["method.request.header.HeaderAuth1",
	// "method.request.querystring.QueryString1"]
	IdentitySource []string `pulumi:"identitySource"`
	// A regular expression for validating the token as the incoming identity. It only invokes the
	// authorizer's lambda if there is a match, else it will return a 401. This does not apply to
	// REQUEST Lambda Authorizers. Example: "^x-[a-z]+".
	IdentityValidationExpression *string `pulumi:"identityValidationExpression"`
	// For method authorization, you can define resource servers and custom scopes by specifying the
	// "resource-server/scope". e.g. ["com.hamuta.movies/drama.view",
	// "http://my.resource.com/file.read"] For more information on resource servers and custom
	// scopes visit the AWS documentation -
	// https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-define-resource-servers.html
	MethodsToAuthorize []string `pulumi:"methodsToAuthorize"`
	// Defines where in the request API Gateway should look for identity information. The value must
	// be "header" or "query". If there are multiple identity sources, the value must be "header".
	ParameterLocation *string `pulumi:"parameterLocation"`
	// parameterName is the name of the header or query parameter containing the authorization
	// token. Must be "Unused" for multiple identity sources.
	ParameterName string `pulumi:"parameterName"`
	// The ARNs of the Cognito User Pools to use.
	ProviderARNs []string `pulumi:"providerARNs"`
	// The type of the authorizer. This value must be one of the following:
	// - "token", for an authorizer with the caller identity embedded in an authorization token
	// - "request", for an authorizer with the caller identity contained in request parameters
	Type *string `pulumi:"type"`
}

// AuthorizerInput is an input type that accepts AuthorizerArgs and AuthorizerOutput values.
// You can construct a concrete instance of `AuthorizerInput` via:
//
//	AuthorizerArgs{...}
type AuthorizerInput interface {
	pulumi.Input

	ToAuthorizerOutput() AuthorizerOutput
	ToAuthorizerOutputWithContext(context.Context) AuthorizerOutput
}

// LambdaAuthorizer provides the definition for a custom Authorizer for API Gateway.
type AuthorizerArgs struct {
	// Specifies the authorization mechanism for the client. Typical values are "oauth2" or "custom".
	AuthType *string `pulumi:"authType"`
	// The name for the Authorizer to be referenced as. This must be unique for each unique
	// authorizer within the API. If no name if specified, a name will be generated for you.
	AuthorizerName *string `pulumi:"authorizerName"`
	// The number of seconds during which the resulting IAM policy is cached. Default is 300s. You
	// can set this value to 0 to disable caching. Max value is 3600s. Note - if you are sharing an
	// authorizer across more than one route you will want to disable the cache or else it will
	// cause problems for you.
	AuthorizerResultTtlInSeconds *float64 `pulumi:"authorizerResultTtlInSeconds"`
	// The authorizerHandler specifies information about the authorizing Lambda.
	Handler lambda.FunctionInput `pulumi:"handler"`
	// List of mapping expressions of the request parameters as the identity source. This indicates
	// where in the request identity information is expected. Applicable for the authorizer of the
	// "request" type only. Example: ["method.request.header.HeaderAuth1",
	// "method.request.querystring.QueryString1"]
	IdentitySource []string `pulumi:"identitySource"`
	// A regular expression for validating the token as the incoming identity. It only invokes the
	// authorizer's lambda if there is a match, else it will return a 401. This does not apply to
	// REQUEST Lambda Authorizers. Example: "^x-[a-z]+".
	IdentityValidationExpression *string `pulumi:"identityValidationExpression"`
	// For method authorization, you can define resource servers and custom scopes by specifying the
	// "resource-server/scope". e.g. ["com.hamuta.movies/drama.view",
	// "http://my.resource.com/file.read"] For more information on resource servers and custom
	// scopes visit the AWS documentation -
	// https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-define-resource-servers.html
	MethodsToAuthorize []string `pulumi:"methodsToAuthorize"`
	// Defines where in the request API Gateway should look for identity information. The value must
	// be "header" or "query". If there are multiple identity sources, the value must be "header".
	ParameterLocation *string `pulumi:"parameterLocation"`
	// parameterName is the name of the header or query parameter containing the authorization
	// token. Must be "Unused" for multiple identity sources.
	ParameterName string `pulumi:"parameterName"`
	// The ARNs of the Cognito User Pools to use.
	ProviderARNs []pulumi.StringInput `pulumi:"providerARNs"`
	// The type of the authorizer. This value must be one of the following:
	// - "token", for an authorizer with the caller identity embedded in an authorization token
	// - "request", for an authorizer with the caller identity contained in request parameters
	Type *string `pulumi:"type"`
}

func (AuthorizerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Authorizer)(nil)).Elem()
}

func (i AuthorizerArgs) ToAuthorizerOutput() AuthorizerOutput {
	return i.ToAuthorizerOutputWithContext(context.Background())
}

func (i AuthorizerArgs) ToAuthorizerOutputWithContext(ctx context.Context) AuthorizerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorizerOutput)
}

// AuthorizerArrayInput is an input type that accepts AuthorizerArray and AuthorizerArrayOutput values.
// You can construct a concrete instance of `AuthorizerArrayInput` via:
//
//	AuthorizerArray{ AuthorizerArgs{...} }
type AuthorizerArrayInput interface {
	pulumi.Input

	ToAuthorizerArrayOutput() AuthorizerArrayOutput
	ToAuthorizerArrayOutputWithContext(context.Context) AuthorizerArrayOutput
}

type AuthorizerArray []AuthorizerInput

func (AuthorizerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Authorizer)(nil)).Elem()
}

func (i AuthorizerArray) ToAuthorizerArrayOutput() AuthorizerArrayOutput {
	return i.ToAuthorizerArrayOutputWithContext(context.Background())
}

func (i AuthorizerArray) ToAuthorizerArrayOutputWithContext(ctx context.Context) AuthorizerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AuthorizerArrayOutput)
}

// LambdaAuthorizer provides the definition for a custom Authorizer for API Gateway.
type AuthorizerOutput struct{ *pulumi.OutputState }

func (AuthorizerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Authorizer)(nil)).Elem()
}

func (o AuthorizerOutput) ToAuthorizerOutput() AuthorizerOutput {
	return o
}

func (o AuthorizerOutput) ToAuthorizerOutputWithContext(ctx context.Context) AuthorizerOutput {
	return o
}

// Specifies the authorization mechanism for the client. Typical values are "oauth2" or "custom".
func (o AuthorizerOutput) AuthType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Authorizer) *string { return v.AuthType }).(pulumi.StringPtrOutput)
}

// The name for the Authorizer to be referenced as. This must be unique for each unique
// authorizer within the API. If no name if specified, a name will be generated for you.
func (o AuthorizerOutput) AuthorizerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Authorizer) *string { return v.AuthorizerName }).(pulumi.StringPtrOutput)
}

// The number of seconds during which the resulting IAM policy is cached. Default is 300s. You
// can set this value to 0 to disable caching. Max value is 3600s. Note - if you are sharing an
// authorizer across more than one route you will want to disable the cache or else it will
// cause problems for you.
func (o AuthorizerOutput) AuthorizerResultTtlInSeconds() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v Authorizer) *float64 { return v.AuthorizerResultTtlInSeconds }).(pulumi.Float64PtrOutput)
}

// The authorizerHandler specifies information about the authorizing Lambda.
func (o AuthorizerOutput) Handler() lambda.FunctionOutput {
	return o.ApplyT(func(v Authorizer) *lambda.Function { return v.Handler }).(lambda.FunctionOutput)
}

// List of mapping expressions of the request parameters as the identity source. This indicates
// where in the request identity information is expected. Applicable for the authorizer of the
// "request" type only. Example: ["method.request.header.HeaderAuth1",
// "method.request.querystring.QueryString1"]
func (o AuthorizerOutput) IdentitySource() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Authorizer) []string { return v.IdentitySource }).(pulumi.StringArrayOutput)
}

// A regular expression for validating the token as the incoming identity. It only invokes the
// authorizer's lambda if there is a match, else it will return a 401. This does not apply to
// REQUEST Lambda Authorizers. Example: "^x-[a-z]+".
func (o AuthorizerOutput) IdentityValidationExpression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Authorizer) *string { return v.IdentityValidationExpression }).(pulumi.StringPtrOutput)
}

// For method authorization, you can define resource servers and custom scopes by specifying the
// "resource-server/scope". e.g. ["com.hamuta.movies/drama.view",
// "http://my.resource.com/file.read"] For more information on resource servers and custom
// scopes visit the AWS documentation -
// https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-define-resource-servers.html
func (o AuthorizerOutput) MethodsToAuthorize() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Authorizer) []string { return v.MethodsToAuthorize }).(pulumi.StringArrayOutput)
}

// Defines where in the request API Gateway should look for identity information. The value must
// be "header" or "query". If there are multiple identity sources, the value must be "header".
func (o AuthorizerOutput) ParameterLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Authorizer) *string { return v.ParameterLocation }).(pulumi.StringPtrOutput)
}

// parameterName is the name of the header or query parameter containing the authorization
// token. Must be "Unused" for multiple identity sources.
func (o AuthorizerOutput) ParameterName() pulumi.StringOutput {
	return o.ApplyT(func(v Authorizer) string { return v.ParameterName }).(pulumi.StringOutput)
}

// The ARNs of the Cognito User Pools to use.
func (o AuthorizerOutput) ProviderARNs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v Authorizer) []string { return v.ProviderARNs }).(pulumi.StringArrayOutput)
}

// The type of the authorizer. This value must be one of the following:
// - "token", for an authorizer with the caller identity embedded in an authorization token
// - "request", for an authorizer with the caller identity contained in request parameters
func (o AuthorizerOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Authorizer) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type AuthorizerArrayOutput struct{ *pulumi.OutputState }

func (AuthorizerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Authorizer)(nil)).Elem()
}

func (o AuthorizerArrayOutput) ToAuthorizerArrayOutput() AuthorizerArrayOutput {
	return o
}

func (o AuthorizerArrayOutput) ToAuthorizerArrayOutputWithContext(ctx context.Context) AuthorizerArrayOutput {
	return o
}

func (o AuthorizerArrayOutput) Index(i pulumi.IntInput) AuthorizerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Authorizer {
		return vs[0].([]Authorizer)[vs[1].(int)]
	}).(AuthorizerOutput)
}

type RequiredParameter struct {
	In   *string `pulumi:"in"`
	Name *string `pulumi:"name"`
}

// RequiredParameterInput is an input type that accepts RequiredParameterArgs and RequiredParameterOutput values.
// You can construct a concrete instance of `RequiredParameterInput` via:
//
//	RequiredParameterArgs{...}
type RequiredParameterInput interface {
	pulumi.Input

	ToRequiredParameterOutput() RequiredParameterOutput
	ToRequiredParameterOutputWithContext(context.Context) RequiredParameterOutput
}

type RequiredParameterArgs struct {
	In   pulumi.StringPtrInput `pulumi:"in"`
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (RequiredParameterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RequiredParameter)(nil)).Elem()
}

func (i RequiredParameterArgs) ToRequiredParameterOutput() RequiredParameterOutput {
	return i.ToRequiredParameterOutputWithContext(context.Background())
}

func (i RequiredParameterArgs) ToRequiredParameterOutputWithContext(ctx context.Context) RequiredParameterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequiredParameterOutput)
}

// RequiredParameterArrayInput is an input type that accepts RequiredParameterArray and RequiredParameterArrayOutput values.
// You can construct a concrete instance of `RequiredParameterArrayInput` via:
//
//	RequiredParameterArray{ RequiredParameterArgs{...} }
type RequiredParameterArrayInput interface {
	pulumi.Input

	ToRequiredParameterArrayOutput() RequiredParameterArrayOutput
	ToRequiredParameterArrayOutputWithContext(context.Context) RequiredParameterArrayOutput
}

type RequiredParameterArray []RequiredParameterInput

func (RequiredParameterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RequiredParameter)(nil)).Elem()
}

func (i RequiredParameterArray) ToRequiredParameterArrayOutput() RequiredParameterArrayOutput {
	return i.ToRequiredParameterArrayOutputWithContext(context.Background())
}

func (i RequiredParameterArray) ToRequiredParameterArrayOutputWithContext(ctx context.Context) RequiredParameterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RequiredParameterArrayOutput)
}

type RequiredParameterOutput struct{ *pulumi.OutputState }

func (RequiredParameterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RequiredParameter)(nil)).Elem()
}

func (o RequiredParameterOutput) ToRequiredParameterOutput() RequiredParameterOutput {
	return o
}

func (o RequiredParameterOutput) ToRequiredParameterOutputWithContext(ctx context.Context) RequiredParameterOutput {
	return o
}

func (o RequiredParameterOutput) In() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RequiredParameter) *string { return v.In }).(pulumi.StringPtrOutput)
}

func (o RequiredParameterOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RequiredParameter) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type RequiredParameterArrayOutput struct{ *pulumi.OutputState }

func (RequiredParameterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RequiredParameter)(nil)).Elem()
}

func (o RequiredParameterArrayOutput) ToRequiredParameterArrayOutput() RequiredParameterArrayOutput {
	return o
}

func (o RequiredParameterArrayOutput) ToRequiredParameterArrayOutputWithContext(ctx context.Context) RequiredParameterArrayOutput {
	return o
}

func (o RequiredParameterArrayOutput) Index(i pulumi.IntInput) RequiredParameterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RequiredParameter {
		return vs[0].([]RequiredParameter)[vs[1].(int)]
	}).(RequiredParameterOutput)
}

// A route that that APIGateway should accept and forward to some type of destination. All routes
// have an incoming path that they match against.  However, destinations are determined by the kind
// of the route.
type Route struct {
	// If true, an API key will be required for this route. The source for the API Key can be set at
	// the API level and by default, the source will be the HEADER.
	ApiKeyRequired *bool `pulumi:"apiKeyRequired"`
	// Authorizers allows you to define Lambda authorizers be applied for authorization when the
	// the route is called.
	Authorizers []Authorizer `pulumi:"authorizers"`
	// The `content-type` to serve the file as.  Only valid when `localPath` points to a file.  If
	// `localPath` points to a directory, the content types for all files will be inferred.
	ContentType *string `pulumi:"contentType"`
	// A raw Swagger object to include verbatim in the integration for this path.
	Data interface{} `pulumi:"data"`
	// A Lambda function which will handle the route for the given path and method.
	EventHandler *lambda.Function `pulumi:"eventHandler"`
	// By default, the route method auth type is set to `NONE`. If true, the auth type will be
	// set to `AWS_IAM`.
	IamAuthEnabled *bool `pulumi:"iamAuthEnabled"`
	// By default a `localPath` hosting static content will also serve 'index.html' in response to a request on a directory.
	// To disable this pass `false` or supply a new index document name.
	Index interface{} `pulumi:"index"`
	// The local path on disk to create static S3 resources for.  Files will be uploaded into S3
	// objects, and directories will be recursively walked into.
	LocalPath *string `pulumi:"localPath"`
	// The REST method of the route to match.  Only valid with `eventHandler` or `data` routes.
	Method *Method `pulumi:"method"`
	// The path on the API that will serve this route.  If not prefixed with `/`,
	// then a `/` will be added automatically to the beginning.
	Path string `pulumi:"path"`
	// Request Validator specifies the validator to use at the method level. This will override anything
	// defined at the API level.
	RequestValidator *RequestValidator `pulumi:"requestValidator"`
	// Required Parameters to validate. If the request validator is set to ALL or PARAMS_ONLY, api
	// gateway will validate these before sending traffic to the event handler.
	RequiredParameters []RequiredParameter `pulumi:"requiredParameters"`
	// The target for an integration route (see https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-integration-types.html).
	Target *Target `pulumi:"target"`
}

// RouteInput is an input type that accepts RouteArgs and RouteOutput values.
// You can construct a concrete instance of `RouteInput` via:
//
//	RouteArgs{...}
type RouteInput interface {
	pulumi.Input

	ToRouteOutput() RouteOutput
	ToRouteOutputWithContext(context.Context) RouteOutput
}

// A route that that APIGateway should accept and forward to some type of destination. All routes
// have an incoming path that they match against.  However, destinations are determined by the kind
// of the route.
type RouteArgs struct {
	// If true, an API key will be required for this route. The source for the API Key can be set at
	// the API level and by default, the source will be the HEADER.
	ApiKeyRequired *bool `pulumi:"apiKeyRequired"`
	// Authorizers allows you to define Lambda authorizers be applied for authorization when the
	// the route is called.
	Authorizers []AuthorizerArgs `pulumi:"authorizers"`
	// The `content-type` to serve the file as.  Only valid when `localPath` points to a file.  If
	// `localPath` points to a directory, the content types for all files will be inferred.
	ContentType *string `pulumi:"contentType"`
	// A raw Swagger object to include verbatim in the integration for this path.
	Data interface{} `pulumi:"data"`
	// A Lambda function which will handle the route for the given path and method.
	EventHandler lambda.FunctionInput `pulumi:"eventHandler"`
	// By default, the route method auth type is set to `NONE`. If true, the auth type will be
	// set to `AWS_IAM`.
	IamAuthEnabled *bool `pulumi:"iamAuthEnabled"`
	// By default a `localPath` hosting static content will also serve 'index.html' in response to a request on a directory.
	// To disable this pass `false` or supply a new index document name.
	Index interface{} `pulumi:"index"`
	// The local path on disk to create static S3 resources for.  Files will be uploaded into S3
	// objects, and directories will be recursively walked into.
	LocalPath *string `pulumi:"localPath"`
	// The REST method of the route to match.  Only valid with `eventHandler` or `data` routes.
	Method *Method `pulumi:"method"`
	// The path on the API that will serve this route.  If not prefixed with `/`,
	// then a `/` will be added automatically to the beginning.
	Path string `pulumi:"path"`
	// Request Validator specifies the validator to use at the method level. This will override anything
	// defined at the API level.
	RequestValidator *RequestValidator `pulumi:"requestValidator"`
	// Required Parameters to validate. If the request validator is set to ALL or PARAMS_ONLY, api
	// gateway will validate these before sending traffic to the event handler.
	RequiredParameters []RequiredParameterArgs `pulumi:"requiredParameters"`
	// The target for an integration route (see https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-integration-types.html).
	Target TargetPtrInput `pulumi:"target"`
}

func (RouteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Route)(nil)).Elem()
}

func (i RouteArgs) ToRouteOutput() RouteOutput {
	return i.ToRouteOutputWithContext(context.Background())
}

func (i RouteArgs) ToRouteOutputWithContext(ctx context.Context) RouteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteOutput)
}

// RouteArrayInput is an input type that accepts RouteArray and RouteArrayOutput values.
// You can construct a concrete instance of `RouteArrayInput` via:
//
//	RouteArray{ RouteArgs{...} }
type RouteArrayInput interface {
	pulumi.Input

	ToRouteArrayOutput() RouteArrayOutput
	ToRouteArrayOutputWithContext(context.Context) RouteArrayOutput
}

type RouteArray []RouteInput

func (RouteArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Route)(nil)).Elem()
}

func (i RouteArray) ToRouteArrayOutput() RouteArrayOutput {
	return i.ToRouteArrayOutputWithContext(context.Background())
}

func (i RouteArray) ToRouteArrayOutputWithContext(ctx context.Context) RouteArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RouteArrayOutput)
}

// A route that that APIGateway should accept and forward to some type of destination. All routes
// have an incoming path that they match against.  However, destinations are determined by the kind
// of the route.
type RouteOutput struct{ *pulumi.OutputState }

func (RouteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Route)(nil)).Elem()
}

func (o RouteOutput) ToRouteOutput() RouteOutput {
	return o
}

func (o RouteOutput) ToRouteOutputWithContext(ctx context.Context) RouteOutput {
	return o
}

// If true, an API key will be required for this route. The source for the API Key can be set at
// the API level and by default, the source will be the HEADER.
func (o RouteOutput) ApiKeyRequired() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Route) *bool { return v.ApiKeyRequired }).(pulumi.BoolPtrOutput)
}

// Authorizers allows you to define Lambda authorizers be applied for authorization when the
// the route is called.
func (o RouteOutput) Authorizers() AuthorizerArrayOutput {
	return o.ApplyT(func(v Route) []Authorizer { return v.Authorizers }).(AuthorizerArrayOutput)
}

// The `content-type` to serve the file as.  Only valid when `localPath` points to a file.  If
// `localPath` points to a directory, the content types for all files will be inferred.
func (o RouteOutput) ContentType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Route) *string { return v.ContentType }).(pulumi.StringPtrOutput)
}

// A raw Swagger object to include verbatim in the integration for this path.
func (o RouteOutput) Data() pulumi.AnyOutput {
	return o.ApplyT(func(v Route) interface{} { return v.Data }).(pulumi.AnyOutput)
}

// A Lambda function which will handle the route for the given path and method.
func (o RouteOutput) EventHandler() lambda.FunctionOutput {
	return o.ApplyT(func(v Route) *lambda.Function { return v.EventHandler }).(lambda.FunctionOutput)
}

// By default, the route method auth type is set to `NONE`. If true, the auth type will be
// set to `AWS_IAM`.
func (o RouteOutput) IamAuthEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v Route) *bool { return v.IamAuthEnabled }).(pulumi.BoolPtrOutput)
}

// By default a `localPath` hosting static content will also serve 'index.html' in response to a request on a directory.
// To disable this pass `false` or supply a new index document name.
func (o RouteOutput) Index() pulumi.AnyOutput {
	return o.ApplyT(func(v Route) interface{} { return v.Index }).(pulumi.AnyOutput)
}

// The local path on disk to create static S3 resources for.  Files will be uploaded into S3
// objects, and directories will be recursively walked into.
func (o RouteOutput) LocalPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Route) *string { return v.LocalPath }).(pulumi.StringPtrOutput)
}

// The REST method of the route to match.  Only valid with `eventHandler` or `data` routes.
func (o RouteOutput) Method() MethodPtrOutput {
	return o.ApplyT(func(v Route) *Method { return v.Method }).(MethodPtrOutput)
}

// The path on the API that will serve this route.  If not prefixed with `/`,
// then a `/` will be added automatically to the beginning.
func (o RouteOutput) Path() pulumi.StringOutput {
	return o.ApplyT(func(v Route) string { return v.Path }).(pulumi.StringOutput)
}

// Request Validator specifies the validator to use at the method level. This will override anything
// defined at the API level.
func (o RouteOutput) RequestValidator() RequestValidatorPtrOutput {
	return o.ApplyT(func(v Route) *RequestValidator { return v.RequestValidator }).(RequestValidatorPtrOutput)
}

// Required Parameters to validate. If the request validator is set to ALL or PARAMS_ONLY, api
// gateway will validate these before sending traffic to the event handler.
func (o RouteOutput) RequiredParameters() RequiredParameterArrayOutput {
	return o.ApplyT(func(v Route) []RequiredParameter { return v.RequiredParameters }).(RequiredParameterArrayOutput)
}

// The target for an integration route (see https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-integration-types.html).
func (o RouteOutput) Target() TargetPtrOutput {
	return o.ApplyT(func(v Route) *Target { return v.Target }).(TargetPtrOutput)
}

type RouteArrayOutput struct{ *pulumi.OutputState }

func (RouteArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Route)(nil)).Elem()
}

func (o RouteArrayOutput) ToRouteArrayOutput() RouteArrayOutput {
	return o
}

func (o RouteArrayOutput) ToRouteArrayOutputWithContext(ctx context.Context) RouteArrayOutput {
	return o
}

func (o RouteArrayOutput) Index(i pulumi.IntInput) RouteOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Route {
		return vs[0].([]Route)[vs[1].(int)]
	}).(RouteOutput)
}

type SwaggerGatewayResponse struct {
	ResponseParameters map[string]string `pulumi:"responseParameters"`
	ResponseTemplates  map[string]string `pulumi:"responseTemplates"`
	StatusCode         *float64          `pulumi:"statusCode"`
}

// SwaggerGatewayResponseInput is an input type that accepts SwaggerGatewayResponseArgs and SwaggerGatewayResponseOutput values.
// You can construct a concrete instance of `SwaggerGatewayResponseInput` via:
//
//	SwaggerGatewayResponseArgs{...}
type SwaggerGatewayResponseInput interface {
	pulumi.Input

	ToSwaggerGatewayResponseOutput() SwaggerGatewayResponseOutput
	ToSwaggerGatewayResponseOutputWithContext(context.Context) SwaggerGatewayResponseOutput
}

type SwaggerGatewayResponseArgs struct {
	ResponseParameters pulumi.StringMapInput  `pulumi:"responseParameters"`
	ResponseTemplates  pulumi.StringMapInput  `pulumi:"responseTemplates"`
	StatusCode         pulumi.Float64PtrInput `pulumi:"statusCode"`
}

func (SwaggerGatewayResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SwaggerGatewayResponse)(nil)).Elem()
}

func (i SwaggerGatewayResponseArgs) ToSwaggerGatewayResponseOutput() SwaggerGatewayResponseOutput {
	return i.ToSwaggerGatewayResponseOutputWithContext(context.Background())
}

func (i SwaggerGatewayResponseArgs) ToSwaggerGatewayResponseOutputWithContext(ctx context.Context) SwaggerGatewayResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SwaggerGatewayResponseOutput)
}

// SwaggerGatewayResponseMapInput is an input type that accepts SwaggerGatewayResponseMap and SwaggerGatewayResponseMapOutput values.
// You can construct a concrete instance of `SwaggerGatewayResponseMapInput` via:
//
//	SwaggerGatewayResponseMap{ "key": SwaggerGatewayResponseArgs{...} }
type SwaggerGatewayResponseMapInput interface {
	pulumi.Input

	ToSwaggerGatewayResponseMapOutput() SwaggerGatewayResponseMapOutput
	ToSwaggerGatewayResponseMapOutputWithContext(context.Context) SwaggerGatewayResponseMapOutput
}

type SwaggerGatewayResponseMap map[string]SwaggerGatewayResponseInput

func (SwaggerGatewayResponseMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]SwaggerGatewayResponse)(nil)).Elem()
}

func (i SwaggerGatewayResponseMap) ToSwaggerGatewayResponseMapOutput() SwaggerGatewayResponseMapOutput {
	return i.ToSwaggerGatewayResponseMapOutputWithContext(context.Background())
}

func (i SwaggerGatewayResponseMap) ToSwaggerGatewayResponseMapOutputWithContext(ctx context.Context) SwaggerGatewayResponseMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SwaggerGatewayResponseMapOutput)
}

type SwaggerGatewayResponseOutput struct{ *pulumi.OutputState }

func (SwaggerGatewayResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SwaggerGatewayResponse)(nil)).Elem()
}

func (o SwaggerGatewayResponseOutput) ToSwaggerGatewayResponseOutput() SwaggerGatewayResponseOutput {
	return o
}

func (o SwaggerGatewayResponseOutput) ToSwaggerGatewayResponseOutputWithContext(ctx context.Context) SwaggerGatewayResponseOutput {
	return o
}

func (o SwaggerGatewayResponseOutput) ResponseParameters() pulumi.StringMapOutput {
	return o.ApplyT(func(v SwaggerGatewayResponse) map[string]string { return v.ResponseParameters }).(pulumi.StringMapOutput)
}

func (o SwaggerGatewayResponseOutput) ResponseTemplates() pulumi.StringMapOutput {
	return o.ApplyT(func(v SwaggerGatewayResponse) map[string]string { return v.ResponseTemplates }).(pulumi.StringMapOutput)
}

func (o SwaggerGatewayResponseOutput) StatusCode() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v SwaggerGatewayResponse) *float64 { return v.StatusCode }).(pulumi.Float64PtrOutput)
}

type SwaggerGatewayResponseMapOutput struct{ *pulumi.OutputState }

func (SwaggerGatewayResponseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]SwaggerGatewayResponse)(nil)).Elem()
}

func (o SwaggerGatewayResponseMapOutput) ToSwaggerGatewayResponseMapOutput() SwaggerGatewayResponseMapOutput {
	return o
}

func (o SwaggerGatewayResponseMapOutput) ToSwaggerGatewayResponseMapOutputWithContext(ctx context.Context) SwaggerGatewayResponseMapOutput {
	return o
}

func (o SwaggerGatewayResponseMapOutput) MapIndex(k pulumi.StringInput) SwaggerGatewayResponseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) SwaggerGatewayResponse {
		return vs[0].(map[string]SwaggerGatewayResponse)[vs[1].(string)]
	}).(SwaggerGatewayResponseOutput)
}

type Target struct {
	// The (id) of the VpcLink used for the integration when connectionType=VPC_LINK and undefined,
	// otherwise.
	ConnectionId *string `pulumi:"connectionId"`
	// The type of the network connection to the integration endpoint. The valid value is `INTERNET`
	// for connections through the public routable internet or `VPC_LINK` for private connections
	// between API Gateway and a network load balancer in a VPC. The default value is `INTERNET`.
	ConnectionType *IntegrationConnectionType `pulumi:"connectionType"`
	// Specifies the integration's HTTP method type.  Currently, the only supported type is 'ANY'.
	HttpMethod *string `pulumi:"httpMethod"`
	// Specifies how the method request body of an unmapped content type will be passed through the
	// integration request to the back end without transformation.
	//
	// The valid value is one of the following:
	//
	// * `WHEN_NO_MATCH`: passes the method request body through the integration request to the back end
	// without transformation when the method request content type does not match any content type
	// associated with the mapping templates defined in the integration request.
	//
	// * `WHEN_NO_TEMPLATES`: passes the method request body through the integration request to the back
	// end without transformation when no mapping template is defined in the integration request. If
	// a template is defined when this option is selected, the method request of an unmapped
	// content-type will be rejected with an HTTP 415 Unsupported Media Type response.
	//
	// * `NEVER`: rejects the method request with an HTTP 415 Unsupported Media Type response when
	// either the method request content type does not match any content type associated with the
	// mapping templates defined in the integration request or no mapping template is defined in the
	// integration request.
	//
	// Defaults to `WHEN_NO_MATCH` if unspecified.
	PassthroughBehaviour *IntegrationPassthroughBehavior `pulumi:"passthroughBehaviour"`
	// Specifies an API method integration type. The valid value is one of the following:
	//
	// * `aws`: for integrating the API method request with an AWS service action, including the Lambda
	// function-invoking action. With the Lambda function-invoking action, this is referred to as
	// the Lambda custom integration. With any other AWS service action, this is known as AWS
	// integration.
	//
	// * `aws_proxy`: for integrating the API method request with the Lambda function-invoking action
	// with the client request passed through as-is. This integration is also referred to as the
	// Lambda proxy integration.
	//
	// * `http`: for integrating the API method request with an HTTP endpoint, including a private HTTP
	// endpoint within a VPC. This integration is also referred to as the HTTP custom integration.
	//
	// * `http_proxy`: for integrating the API method request with an HTTP endpoint, including a private
	// HTTP endpoint within a VPC, with the client request passed through as-is. This is also
	// referred to as the HTTP proxy integration.
	//
	// * `mock`: for integrating the API method request with API Gateway as a "loop-back" endpoint
	// without invoking any backend.
	Type IntegrationType `pulumi:"type"`
	// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
	//
	// For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL
	// according to the RFC-3986 specification, for either standard integration, where
	// connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For
	// a private HTTP integration, the URI is not used for routing.
	//
	// For AWS or AWS_PROXY integrations, the URI is of the form
	// arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here,
	// {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated
	// AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS
	// service for fast host-name lookup. action can be used for an AWS service action-based API,
	// using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to
	// a supported action {name} plus any required input parameters. Alternatively, path can be used
	// for an AWS service path-based API. The ensuing service_api refers to the path to an AWS
	// service resource, including the region of the integrated AWS service, if applicable. For
	// example, for integration with the S3 API of GetObject, the uri can be either
	// arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or
	// arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}.
	Uri string `pulumi:"uri"`
}

// TargetInput is an input type that accepts TargetArgs and TargetOutput values.
// You can construct a concrete instance of `TargetInput` via:
//
//	TargetArgs{...}
type TargetInput interface {
	pulumi.Input

	ToTargetOutput() TargetOutput
	ToTargetOutputWithContext(context.Context) TargetOutput
}

type TargetArgs struct {
	// The (id) of the VpcLink used for the integration when connectionType=VPC_LINK and undefined,
	// otherwise.
	ConnectionId pulumi.StringPtrInput `pulumi:"connectionId"`
	// The type of the network connection to the integration endpoint. The valid value is `INTERNET`
	// for connections through the public routable internet or `VPC_LINK` for private connections
	// between API Gateway and a network load balancer in a VPC. The default value is `INTERNET`.
	ConnectionType IntegrationConnectionTypePtrInput `pulumi:"connectionType"`
	// Specifies the integration's HTTP method type.  Currently, the only supported type is 'ANY'.
	HttpMethod pulumi.StringPtrInput `pulumi:"httpMethod"`
	// Specifies how the method request body of an unmapped content type will be passed through the
	// integration request to the back end without transformation.
	//
	// The valid value is one of the following:
	//
	// * `WHEN_NO_MATCH`: passes the method request body through the integration request to the back end
	// without transformation when the method request content type does not match any content type
	// associated with the mapping templates defined in the integration request.
	//
	// * `WHEN_NO_TEMPLATES`: passes the method request body through the integration request to the back
	// end without transformation when no mapping template is defined in the integration request. If
	// a template is defined when this option is selected, the method request of an unmapped
	// content-type will be rejected with an HTTP 415 Unsupported Media Type response.
	//
	// * `NEVER`: rejects the method request with an HTTP 415 Unsupported Media Type response when
	// either the method request content type does not match any content type associated with the
	// mapping templates defined in the integration request or no mapping template is defined in the
	// integration request.
	//
	// Defaults to `WHEN_NO_MATCH` if unspecified.
	PassthroughBehaviour IntegrationPassthroughBehaviorPtrInput `pulumi:"passthroughBehaviour"`
	// Specifies an API method integration type. The valid value is one of the following:
	//
	// * `aws`: for integrating the API method request with an AWS service action, including the Lambda
	// function-invoking action. With the Lambda function-invoking action, this is referred to as
	// the Lambda custom integration. With any other AWS service action, this is known as AWS
	// integration.
	//
	// * `aws_proxy`: for integrating the API method request with the Lambda function-invoking action
	// with the client request passed through as-is. This integration is also referred to as the
	// Lambda proxy integration.
	//
	// * `http`: for integrating the API method request with an HTTP endpoint, including a private HTTP
	// endpoint within a VPC. This integration is also referred to as the HTTP custom integration.
	//
	// * `http_proxy`: for integrating the API method request with an HTTP endpoint, including a private
	// HTTP endpoint within a VPC, with the client request passed through as-is. This is also
	// referred to as the HTTP proxy integration.
	//
	// * `mock`: for integrating the API method request with API Gateway as a "loop-back" endpoint
	// without invoking any backend.
	Type IntegrationTypeInput `pulumi:"type"`
	// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
	//
	// For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL
	// according to the RFC-3986 specification, for either standard integration, where
	// connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For
	// a private HTTP integration, the URI is not used for routing.
	//
	// For AWS or AWS_PROXY integrations, the URI is of the form
	// arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here,
	// {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated
	// AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS
	// service for fast host-name lookup. action can be used for an AWS service action-based API,
	// using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to
	// a supported action {name} plus any required input parameters. Alternatively, path can be used
	// for an AWS service path-based API. The ensuing service_api refers to the path to an AWS
	// service resource, including the region of the integrated AWS service, if applicable. For
	// example, for integration with the S3 API of GetObject, the uri can be either
	// arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or
	// arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}.
	Uri pulumi.StringInput `pulumi:"uri"`
}

func (TargetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Target)(nil)).Elem()
}

func (i TargetArgs) ToTargetOutput() TargetOutput {
	return i.ToTargetOutputWithContext(context.Background())
}

func (i TargetArgs) ToTargetOutputWithContext(ctx context.Context) TargetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TargetOutput)
}

func (i TargetArgs) ToTargetPtrOutput() TargetPtrOutput {
	return i.ToTargetPtrOutputWithContext(context.Background())
}

func (i TargetArgs) ToTargetPtrOutputWithContext(ctx context.Context) TargetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TargetOutput).ToTargetPtrOutputWithContext(ctx)
}

// TargetPtrInput is an input type that accepts TargetArgs, TargetPtr and TargetPtrOutput values.
// You can construct a concrete instance of `TargetPtrInput` via:
//
//	        TargetArgs{...}
//
//	or:
//
//	        nil
type TargetPtrInput interface {
	pulumi.Input

	ToTargetPtrOutput() TargetPtrOutput
	ToTargetPtrOutputWithContext(context.Context) TargetPtrOutput
}

type targetPtrType TargetArgs

func TargetPtr(v *TargetArgs) TargetPtrInput {
	return (*targetPtrType)(v)
}

func (*targetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Target)(nil)).Elem()
}

func (i *targetPtrType) ToTargetPtrOutput() TargetPtrOutput {
	return i.ToTargetPtrOutputWithContext(context.Background())
}

func (i *targetPtrType) ToTargetPtrOutputWithContext(ctx context.Context) TargetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TargetPtrOutput)
}

type TargetOutput struct{ *pulumi.OutputState }

func (TargetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Target)(nil)).Elem()
}

func (o TargetOutput) ToTargetOutput() TargetOutput {
	return o
}

func (o TargetOutput) ToTargetOutputWithContext(ctx context.Context) TargetOutput {
	return o
}

func (o TargetOutput) ToTargetPtrOutput() TargetPtrOutput {
	return o.ToTargetPtrOutputWithContext(context.Background())
}

func (o TargetOutput) ToTargetPtrOutputWithContext(ctx context.Context) TargetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Target) *Target {
		return &v
	}).(TargetPtrOutput)
}

// The (id) of the VpcLink used for the integration when connectionType=VPC_LINK and undefined,
// otherwise.
func (o TargetOutput) ConnectionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Target) *string { return v.ConnectionId }).(pulumi.StringPtrOutput)
}

// The type of the network connection to the integration endpoint. The valid value is `INTERNET`
// for connections through the public routable internet or `VPC_LINK` for private connections
// between API Gateway and a network load balancer in a VPC. The default value is `INTERNET`.
func (o TargetOutput) ConnectionType() IntegrationConnectionTypePtrOutput {
	return o.ApplyT(func(v Target) *IntegrationConnectionType { return v.ConnectionType }).(IntegrationConnectionTypePtrOutput)
}

// Specifies the integration's HTTP method type.  Currently, the only supported type is 'ANY'.
func (o TargetOutput) HttpMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Target) *string { return v.HttpMethod }).(pulumi.StringPtrOutput)
}

// Specifies how the method request body of an unmapped content type will be passed through the
// integration request to the back end without transformation.
//
// The valid value is one of the following:
//
// * `WHEN_NO_MATCH`: passes the method request body through the integration request to the back end
// without transformation when the method request content type does not match any content type
// associated with the mapping templates defined in the integration request.
//
// * `WHEN_NO_TEMPLATES`: passes the method request body through the integration request to the back
// end without transformation when no mapping template is defined in the integration request. If
// a template is defined when this option is selected, the method request of an unmapped
// content-type will be rejected with an HTTP 415 Unsupported Media Type response.
//
// * `NEVER`: rejects the method request with an HTTP 415 Unsupported Media Type response when
// either the method request content type does not match any content type associated with the
// mapping templates defined in the integration request or no mapping template is defined in the
// integration request.
//
// Defaults to `WHEN_NO_MATCH` if unspecified.
func (o TargetOutput) PassthroughBehaviour() IntegrationPassthroughBehaviorPtrOutput {
	return o.ApplyT(func(v Target) *IntegrationPassthroughBehavior { return v.PassthroughBehaviour }).(IntegrationPassthroughBehaviorPtrOutput)
}

// Specifies an API method integration type. The valid value is one of the following:
//
// * `aws`: for integrating the API method request with an AWS service action, including the Lambda
// function-invoking action. With the Lambda function-invoking action, this is referred to as
// the Lambda custom integration. With any other AWS service action, this is known as AWS
// integration.
//
// * `aws_proxy`: for integrating the API method request with the Lambda function-invoking action
// with the client request passed through as-is. This integration is also referred to as the
// Lambda proxy integration.
//
// * `http`: for integrating the API method request with an HTTP endpoint, including a private HTTP
// endpoint within a VPC. This integration is also referred to as the HTTP custom integration.
//
// * `http_proxy`: for integrating the API method request with an HTTP endpoint, including a private
// HTTP endpoint within a VPC, with the client request passed through as-is. This is also
// referred to as the HTTP proxy integration.
//
// * `mock`: for integrating the API method request with API Gateway as a "loop-back" endpoint
// without invoking any backend.
func (o TargetOutput) Type() IntegrationTypeOutput {
	return o.ApplyT(func(v Target) IntegrationType { return v.Type }).(IntegrationTypeOutput)
}

// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
//
// For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL
// according to the RFC-3986 specification, for either standard integration, where
// connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For
// a private HTTP integration, the URI is not used for routing.
//
// For AWS or AWS_PROXY integrations, the URI is of the form
// arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here,
// {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated
// AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS
// service for fast host-name lookup. action can be used for an AWS service action-based API,
// using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to
// a supported action {name} plus any required input parameters. Alternatively, path can be used
// for an AWS service path-based API. The ensuing service_api refers to the path to an AWS
// service resource, including the region of the integrated AWS service, if applicable. For
// example, for integration with the S3 API of GetObject, the uri can be either
// arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or
// arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}.
func (o TargetOutput) Uri() pulumi.StringOutput {
	return o.ApplyT(func(v Target) string { return v.Uri }).(pulumi.StringOutput)
}

type TargetPtrOutput struct{ *pulumi.OutputState }

func (TargetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Target)(nil)).Elem()
}

func (o TargetPtrOutput) ToTargetPtrOutput() TargetPtrOutput {
	return o
}

func (o TargetPtrOutput) ToTargetPtrOutputWithContext(ctx context.Context) TargetPtrOutput {
	return o
}

func (o TargetPtrOutput) Elem() TargetOutput {
	return o.ApplyT(func(v *Target) Target {
		if v != nil {
			return *v
		}
		var ret Target
		return ret
	}).(TargetOutput)
}

// The (id) of the VpcLink used for the integration when connectionType=VPC_LINK and undefined,
// otherwise.
func (o TargetPtrOutput) ConnectionId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Target) *string {
		if v == nil {
			return nil
		}
		return v.ConnectionId
	}).(pulumi.StringPtrOutput)
}

// The type of the network connection to the integration endpoint. The valid value is `INTERNET`
// for connections through the public routable internet or `VPC_LINK` for private connections
// between API Gateway and a network load balancer in a VPC. The default value is `INTERNET`.
func (o TargetPtrOutput) ConnectionType() IntegrationConnectionTypePtrOutput {
	return o.ApplyT(func(v *Target) *IntegrationConnectionType {
		if v == nil {
			return nil
		}
		return v.ConnectionType
	}).(IntegrationConnectionTypePtrOutput)
}

// Specifies the integration's HTTP method type.  Currently, the only supported type is 'ANY'.
func (o TargetPtrOutput) HttpMethod() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Target) *string {
		if v == nil {
			return nil
		}
		return v.HttpMethod
	}).(pulumi.StringPtrOutput)
}

// Specifies how the method request body of an unmapped content type will be passed through the
// integration request to the back end without transformation.
//
// The valid value is one of the following:
//
// * `WHEN_NO_MATCH`: passes the method request body through the integration request to the back end
// without transformation when the method request content type does not match any content type
// associated with the mapping templates defined in the integration request.
//
// * `WHEN_NO_TEMPLATES`: passes the method request body through the integration request to the back
// end without transformation when no mapping template is defined in the integration request. If
// a template is defined when this option is selected, the method request of an unmapped
// content-type will be rejected with an HTTP 415 Unsupported Media Type response.
//
// * `NEVER`: rejects the method request with an HTTP 415 Unsupported Media Type response when
// either the method request content type does not match any content type associated with the
// mapping templates defined in the integration request or no mapping template is defined in the
// integration request.
//
// Defaults to `WHEN_NO_MATCH` if unspecified.
func (o TargetPtrOutput) PassthroughBehaviour() IntegrationPassthroughBehaviorPtrOutput {
	return o.ApplyT(func(v *Target) *IntegrationPassthroughBehavior {
		if v == nil {
			return nil
		}
		return v.PassthroughBehaviour
	}).(IntegrationPassthroughBehaviorPtrOutput)
}

// Specifies an API method integration type. The valid value is one of the following:
//
// * `aws`: for integrating the API method request with an AWS service action, including the Lambda
// function-invoking action. With the Lambda function-invoking action, this is referred to as
// the Lambda custom integration. With any other AWS service action, this is known as AWS
// integration.
//
// * `aws_proxy`: for integrating the API method request with the Lambda function-invoking action
// with the client request passed through as-is. This integration is also referred to as the
// Lambda proxy integration.
//
// * `http`: for integrating the API method request with an HTTP endpoint, including a private HTTP
// endpoint within a VPC. This integration is also referred to as the HTTP custom integration.
//
// * `http_proxy`: for integrating the API method request with an HTTP endpoint, including a private
// HTTP endpoint within a VPC, with the client request passed through as-is. This is also
// referred to as the HTTP proxy integration.
//
// * `mock`: for integrating the API method request with API Gateway as a "loop-back" endpoint
// without invoking any backend.
func (o TargetPtrOutput) Type() IntegrationTypePtrOutput {
	return o.ApplyT(func(v *Target) *IntegrationType {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(IntegrationTypePtrOutput)
}

// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
//
// For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL
// according to the RFC-3986 specification, for either standard integration, where
// connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For
// a private HTTP integration, the URI is not used for routing.
//
// For AWS or AWS_PROXY integrations, the URI is of the form
// arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here,
// {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated
// AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS
// service for fast host-name lookup. action can be used for an AWS service action-based API,
// using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to
// a supported action {name} plus any required input parameters. Alternatively, path can be used
// for an AWS service path-based API. The ensuing service_api refers to the path to an AWS
// service resource, including the region of the integrated AWS service, if applicable. For
// example, for integration with the S3 API of GetObject, the uri can be either
// arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or
// arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}.
func (o TargetPtrOutput) Uri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Target) *string {
		if v == nil {
			return nil
		}
		return &v.Uri
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AuthorizerInput)(nil)).Elem(), AuthorizerArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AuthorizerArrayInput)(nil)).Elem(), AuthorizerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RequiredParameterInput)(nil)).Elem(), RequiredParameterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RequiredParameterArrayInput)(nil)).Elem(), RequiredParameterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RouteInput)(nil)).Elem(), RouteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RouteArrayInput)(nil)).Elem(), RouteArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SwaggerGatewayResponseInput)(nil)).Elem(), SwaggerGatewayResponseArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SwaggerGatewayResponseMapInput)(nil)).Elem(), SwaggerGatewayResponseMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*TargetInput)(nil)).Elem(), TargetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TargetPtrInput)(nil)).Elem(), TargetArgs{})
	pulumi.RegisterOutputType(AuthorizerOutput{})
	pulumi.RegisterOutputType(AuthorizerArrayOutput{})
	pulumi.RegisterOutputType(RequiredParameterOutput{})
	pulumi.RegisterOutputType(RequiredParameterArrayOutput{})
	pulumi.RegisterOutputType(RouteOutput{})
	pulumi.RegisterOutputType(RouteArrayOutput{})
	pulumi.RegisterOutputType(SwaggerGatewayResponseOutput{})
	pulumi.RegisterOutputType(SwaggerGatewayResponseMapOutput{})
	pulumi.RegisterOutputType(TargetOutput{})
	pulumi.RegisterOutputType(TargetPtrOutput{})
}
